# 001 - Architecture

## Colourfully Digital Foundation Website Architecture Document

### Introduction / Preamble

This document outlines the overall project architecture, including backend systems, shared services, and non-UI-specific concerns. Its primary goal is to serve as the guiding architectural blueprint for AI-driven development, ensuring consistency and adherence to chosen patterns and technologies.

#### Relationship to Frontend Architecture:

This project includes a significant user interface. A separate Frontend Architecture Document will be created later to detail the frontend-specific design, and it MUST be used in conjunction with this document. Core technology stack choices documented herein are definitive for the entire project, including all frontend components.

## Table of Contents

- [Colourfully Digital Foundation Website Architecture Document](#colourfully-digital-foundation-website-architecture-document)
  - [Introduction / Preamble](#introduction--preamble)
  - [Technical Summary](#technical-summary)
  - [High-Level Overview](#high-level-overview)
  - [Architectural / Design Patterns Adopted](#architectural--design-patterns-adopted)
  - [Component View](#component-view)
  - [Project Structure](#project-structure)
  - [Key Directory Descriptions](#key-directory-descriptions)
  - [API Reference](#api-reference)
    - [External APIs Consumed](#external-apis-consumed)
      - [Storyblok API](#storyblok-api)
      - [Eventbrite API](#eventbrite-api)
      - [EmailOctopus API](#emailoctopus-api)
      - [Make.com Webhook](#makecom-webhook)
      - [Google Analytics 4](#google-analytics-4)
  - [Data Models](#data-models)
    - [Core Application Entities / Domain Objects](#core-application-entities--domain-objects)
      - [Program](#program)
      - [BlogPost](#blogpost)
      - [Partner](#partner)
    - [API Payload Schemas](#api-payload-schemas)
      - [VolunteerApplicationPayload](#volunteerapplicationpayload)
      - [NewsletterSubscriptionPayload](#newslettersubscriptionpayload)
      - [MakeWebhookPayload](#makewebhookpayload)
    - [Database Schemas](#database-schemas)
  - [Core Workflow / Sequence Diagrams](#core-workflow--sequence-diagrams)
    - [Workflow 1: Volunteer Application Submission](#workflow-1-volunteer-application-submission)
    - [Workflow 2: Content Update and Deployment](#workflow-2-content-update-and-deployment)
    - [Workflow 3: Interactive Program Filtering (Client-Side)](#workflow-3-interactive-program-filtering-client-side)
  - [Definitive Tech Stack Selections](#definitive-tech-stack-selections)
  - [Infrastructure and Deployment Overview](#infrastructure-and-deployment-overview)
  - [Error Handling Strategy](#error-handling-strategy)
    - [General Approach](#general-approach)
    - [Logging](#logging)
    - [Specific Handling Patterns](#specific-handling-patterns)
  - [Coding Standards](#coding-standards)
    - [Detailed Language & Framework Conventions (TypeScript/Node.js)](#detailed-language--framework-conventions-typescriptnodejs)
  - [Overall Testing Strategy](#overall-testing-strategy)
  - [Security Best Practices](#security-best-practices)
  - [Conclusion](#conclusion)
## Technical Summary

This document outlines a headless architecture for the Colourfully Digital Foundation website. The primary goal is to create a flexible, scalable, and maintainable platform to support the foundation's mission of providing accessible STEM education. The system will leverage Storyblok as a headless CMS for all content, a statically-generated frontend built with Astro and interactive React components, and a serverless backend using Netlify Functions for dynamic operations like form submissions. All code will be managed within a single monorepo to facilitate code sharing and streamlined development.

## High-Level Overview

The system employs a Headless and Serverless architectural style, fully contained within a Monorepo. This approach decouples the content management (the "head") from the presentation layer (the frontend), providing significant flexibility and performance benefits.

The primary user interaction flow is as follows:

1. A Website Visitor accesses the site, which is served statically from Netlify's global CDN for maximum speed.

2. The content for these pages was pre-rendered at build time by sourcing data from the Storyblok CMS.

3. Interactive features, such as forms and filters, are handled by client-side React components. These components make calls to Netlify Functions for any backend processing.

4. A Content Editor manages all website content within the Storyblok user interface. Publishing changes in Storyblok can trigger a new build and deployment of the website via a configured webhook.

Here is a C4 System Context diagram illustrating the main relationships:



```
C4Context
  title System Context Diagram for Colourfully Digital Foundation Website
  Person(visitor, "Website Visitor", "The public user of the website.")
  Person(editor, "Content Editor", "Foundation staff managing website content.")
  System_Ext(storyblok, "Storyblok CMS", "Headless Content Management System for all website content.")
  System_Ext(eventbrite, "Eventbrite", "External service for program registration.")
  System_Ext(emailoctopus, "EmailOctopus", "Handles newsletter subscriptions and automated email notifications.")
  System_Ext(ga, "Google Analytics 4", "Tracks user behavior and site performance.")
  System_Boundary(c1, "Colourfully Digital Foundation Platform") {
    System(website, "Website (Astro + React)", "Provides information, program details, and volunteer opportunities. Statically hosted on Netlify.")
    System(functions, "Serverless Functions (Netlify)", "Handles backend logic for form submissions and subscriptions.")
  }
  Rel(visitor, website, "Views content, submits forms")
  Rel(website, ga, "Sends user behavior data", "HTTPS")
  Rel(website, eventbrite, "Redirects for registration", "HTTPS")
  Rel_Back(website, visitor, "Serves static pages and UI")
  Rel(website, functions, "Invokes for dynamic actions", "HTTPS/JSON")
  Rel(functions, emailoctopus, "Adds subscribers and sends emails", "HTTPS/JSON")
  Rel(editor, storyblok, "Manages all content", "HTTPS")
  Rel(website, storyblok, "Provides content via API at build time", "HTTPS/JSON")
  Rel(storyblok, functions, "Can trigger rebuilds via webhook", "HTTPS")
```
## Architectural / Design Patterns Adopted

The following high-level patterns have been chosen to meet the project's requirements for performance, scalability, and maintainability. All development, both by human and AI agents, must adhere to these patterns.

### Static Site Generation (SSG)

**Rationale**: The core of the website will be pre-built into static HTML, CSS, and JavaScript files. This approach, native to Astro, provides maximum performance for visitors, enhances security by minimizing the server-side attack surface, and ensures high reliability and scalability when deployed to a global CDN like Netlify's.

### Island Architecture

**Rationale**: For features requiring user interaction (forms, filters, etc.), we will use the "Island Architecture" pattern. Most of the site remains static, non-interactive HTML, while individual React components are hydrated as isolated "islands" of interactivity. This drastically reduces the amount of JavaScript shipped to the client, leading to faster load times and better Core Web Vitals.

### Serverless Functions (Function as a Service - FaaS)

**Rationale**: All backend logic, such as processing volunteer applications and newsletter subscriptions, will be handled by discrete, on-demand serverless functions hosted on Netlify. This pattern is highly cost-effective and scales automatically without the need to manage traditional server infrastructure.

### Repository Pattern

**Rationale**: Data access to external systems, primarily the Storyblok CMS, will be encapsulated within a dedicated repository layer (e.g., in the packages/storyblok-client package). This decouples our application's business logic from the specific implementation details of the data source, making the code easier to maintain, test, and adapt if data sources change in the future.

## Component View

The system is composed of several distinct logical components that work together to deliver the required functionality. The primary components are the user-facing Frontend Application, a set of backend Serverless Functions for dynamic processing, and several external services for content management and automation.

### Frontend Application (Astro + React Islands)
This is the core, user-facing website. Its primary responsibility is to fetch content from the Storyblok CMS at build time and render it as fast, static HTML pages. It also hosts interactive React components ("islands") to handle dynamic user actions like form submissions and content filtering.

### Serverless API (Netlify Functions)
This represents our backend logic. It is a collection of individual, single-purpose functions that handle specific tasks. They are invoked directly by the Frontend Application.

- **Volunteer Application Service**: A function responsible for receiving data from the volunteer form, validating it, forwarding details to EmailOctopus for internal/applicant notifications, and triggering a Make.com automation via a webhook to generate and email the Vulnerable Sector Check letter to the applicant.

- **Newsletter Subscription Service**: A function that handles sign-ups for both the public and volunteer newsletters, adding subscribers to the correct list in EmailOctopus.

### Content Store (Storyblok CMS)
An external headless CMS that acts as the single source of truth for all website content. Content Editors interact exclusively with this system to manage all text and media, which is then consumed by the Frontend Application.



```
C4Container
  title Container Diagram for Colourfully Digital Foundation Platform (Revised)
  Person(visitor, "Website Visitor", "Uses the website to find information and volunteer.")
  Person(editor, "Content Editor", "Manages content within the CMS.")
  System_Ext(storyblok, "Storyblok CMS", "SaaS: The source of all content.")
  System_Ext(eventbrite, "Eventbrite", "SaaS: Handles program registrations.")
  System_Ext(emailoctopus, "EmailOctopus", "SaaS: Manages mailing lists and sends initial emails.")
  System_Ext(make, "Make.com", "SaaS: Workflow automation for document generation.")
  System_Ext(ga, "Google Analytics", "SaaS: Provides analytics on user behavior.")
  System_Boundary(c1, "Colourfully Digital Foundation Platform (Hosted on Netlify)") {
    Container(website, "Frontend Application", "Astro + React", "The statically-generated website that the user interacts with.")
    Container(functions, "Serverless API", "Node.js/TypeScript", "Handles dynamic backend logic like form submissions.")
    Rel(visitor, website, "Views pages, submits forms", "HTTPS")
    Rel(website, functions, "Calls API for dynamic actions", "HTTPS/JSON")
    Rel_Back(functions, website, "Returns success/error responses")
  }
  Rel(website, ga, "Sends analytics events", "HTTPS")
  Rel(website, eventbrite, "Redirects user to register", "HTTPS")
  Rel(functions, emailoctopus, "Sends notifications and subscriber data", "HTTPS/JSON")
  Rel(functions, make, "Triggers document generation workflow", "Webhook")
  Rel(editor, storyblok, "Manages content")
  Rel(website, storyblok, "Reads content at build time", "API")
  Rel(storyblok, c1, "Triggers new builds via webhook", "HTTPS")
```
## Project Structure

This project will be organized as a monorepo, managed by pnpm workspaces and orchestrated by Turborepo. This structure allows for clear separation between applications and shared code.



```
colourfully-digital-monorepo/
├── .github/                    # CI/CD workflows (e.g., GitHub Actions)
│   └── workflows/
│       └── main.yml
│       └── copilot-instructions.md
├── .vscode/                    # VSCode settings (optional)
│   └── settings.json
├── apps/                       # Contains discrete, deployable applications.
│   └── website/                # The main Astro marketing and community site.
│       ├── public/
│       ├── src/
│       ├── astro.config.mjs
│       └── package.json
├── docs/                       # Project documentation (PRD, Arch, etc.)
│   └── architecture.md
├── netlify/                    # Configuration and code for the Netlify platform.
│   ├── functions/              # Location for all serverless backend functions.
│   │   ├── submit-volunteer-application.mjs
│   │   └── subscribe-newsletter.mjs
│   └── netlify.toml            # Netlify deployment and configuration file.
├── packages/                   # Shared libraries/packages used across apps.
│   ├── storyblok-client/       # A dedicated package for interacting with the Storyblok API.
│   │   ├── index.ts
│   │   └── package.json
│   ├── types/                  # Shared TypeScript types and interfaces.
│   │   ├── index.ts
│   │   └── package.json
│   └── ui/                     # Shared, reusable React UI components (Buttons, Cards, etc.).
│       ├── components/
│       └── package.json
├── .gitignore                  # Git ignore rules.
├── package.json                # Root package.json for the monorepo.
├── pnpm-workspace.yaml         # Defines the pnpm workspace structure.
├── tsconfig.json               # Root TypeScript configuration for the monorepo.
└── turbo.json                  # Turborepo pipeline configuration.
```
## Key Directory Descriptions

- **apps/**: This directory contains all deployable applications. The primary application for the MVP is website. Future applications like shop.colourfully.digital would be added as new folders within this directory.

- **docs/**: Contains all project planning and reference documentation, including this Architecture Document.

- **netlify/**: This directory holds all assets related to the Netlify platform. The netlify/functions/ subdirectory is the exclusive location for our serverless backend logic.

- **packages/**: This is a crucial directory for reusable code.

  - **storyblok-client**: Will contain a pre-configured client for fetching data from Storyblok, ensuring consistent API interaction.

  - **types**: Will house shared TypeScript definitions (e.g., for a Program or BlogPost) to ensure type safety between the frontend and any other part of the system.

  - **ui**: Will be our shared React component library, promoting a consistent look and feel across all interactive parts of the current site and any future applications.

## API Reference

This section details all external APIs consumed by the system. All API keys and secret URLs will be managed as environment variables within the Netlify platform and must not be hardcoded in the source code.

### External APIs Consumed
#### Storyblok API

**Purpose**: To serve as the primary content source for the website. The Astro frontend will query this API exclusively at build time to pre-render all pages.

**Base URL**: https://api.storyblok.com/v2/cdn/

**Authentication**: A public API Key (token) provided by Storyblok will be used. This key will be stored as an environment variable.

**Key Endpoints Used**:

- GET /stories:
  - **Description**: The primary endpoint for fetching all content. It will be used with various query parameters (starts_with, by_slugs, version, etc.) to retrieve specific pages, programs, blog posts, and other content types.
  - **Response Schema**: The response schema is dynamic and corresponds to the structure of the "Bloks" defined within the Storyblok CMS. These structures will be mapped to TypeScript interfaces in our packages/types/ directory for type safety.

**Link to Official Docs**: https://www.storyblok.com/docs/api/content-delivery

#### Eventbrite API

**Purpose**: To handle user registration for specific programs like the "Black Boys Code" program.

**Interaction Method**: For the MVP, the integration will be a direct hyperlink. There will be no server-to-server API calls. The "Register" button on the website will link directly to the public event page on eventbrite.com.

**Rationale**: This is the most secure and straightforward approach for the MVP, as it eliminates the need to manage Eventbrite API keys and build a custom checkout flow.

#### EmailOctopus API

**Purpose**: Called by our Netlify Functions to manage newsletter subscriptions and send initial transactional confirmation emails (e.g., after a volunteer application is received).

**Base URL**: https://emailoctopus.com/api/1.6/

**Authentication**: An API Key stored as a secure Netlify environment variable.

**Key Endpoints Used**:

- POST /lists/{list_id}/contacts:
  - **Description**: Used to add a new contact to a specified mailing list (e.g., "Public Newsletter" or "Volunteer Newsletter"). This endpoint will be called by our subscribe-newsletter and submit-volunteer-application Netlify functions. It will be configured to trigger the double opt-in process.
  - **Request Body Schema**: 
    ```json
    { 
      "api_key": "...", 
      "email_address": "...", 
      "fields": { 
        "FirstName": "...", 
        "LastName": "..." 
      }, 
      "status": "PENDING" 
    }
    ```

**Link to Official Docs**: https://emailoctopus.com/api-documentation

#### Make.com Webhook

**Purpose**: Called by the submit-volunteer-application Netlify function to trigger a workflow that generates and emails the Vulnerable Sector Check PDF.

**Interaction Method**: A POST request to a unique, secret webhook URL provided by Make.

**Authentication**: The secrecy of the webhook URL itself serves as the authentication mechanism. The URL will be stored as a secure Netlify environment variable.

**Key Endpoints Used**:

- POST /{secret-webhook-path}:
  - **Description**: Triggers the automation workflow in Make.
  - **Request Body Schema**: The Netlify function will send a JSON payload containing the applicant's data required for the PDF template. Example: 
    ```json
    { 
      "applicant_email": "...", 
      "applicant_firstname": "...", 
      "applicant_lastname": "...", 
      "application_date": "..." 
    }
    ```

#### Google Analytics 4

**Purpose**: To track website traffic and user interactions for performance analysis.

**Interaction Method**: The integration will be purely client-side using the Google gtag.js library. The library will be loaded on the frontend, and no backend API calls will be made from our system.

**Implementation**: The Google Analytics tracking script and Measurement ID will be added to the website's global layout (BaseLayout.astro). Custom events (e.g., for form submissions) will be dispatched from the relevant client-side React components.

## Data Models

### Core Application Entities / Domain Objects

These are the primary "nouns" of our system, representing the main objects the application works with. Most of these structures will directly map to the content models created in the Storyblok CMS.

#### Program

**Description**: Represents a single STEM program or workshop offered by the foundation.

**Schema / Interface Definition**:

```typescript
export interface Program {
  id: string;         // Unique identifier from Storyblok
  slug: string;       // URL-friendly identifier
  title: string;
  description: string;  // Rich text or markdown content
  heroImage: {
    url: string;
    alt: string;
  };
  ageGroup: string;   // e.g., "8-12", "13-17"
  topic: string;      // e.g., "Coding", "Robotics"
  format: 'Online' | 'In-Person' | 'Hybrid';
  registrationUrl?: string; // Optional direct link for registration
}
```
#### BlogPost

**Description**: Represents a single article, success story, or event recap in the Impact Storytelling Blog.

**Schema / Interface Definition**:

```typescript
export interface BlogPost {
  id: string;
  slug: string;
  title: string;
  publishDate: string; // ISO 8601 Date string
  featuredImage: {
    url: string;
    alt: string;
  };
  summary: string;
  content: any; // Represents Storyblok's rich text object
  categories: string[]; // e.g., ["Success Story", "Volunteer"]
}
```
#### Partner

**Description**: Represents a single partner or sponsor organization.

**Schema / Interface Definition**:

```typescript
export interface Partner {
  id: string;
  name: string;
  logo: {
    url: string;
    alt: string;
  };
  description: string;
  websiteUrl: string;
  type: 'Educational' | 'Corporate' | 'Community';
}
```
### API Payload Schemas

These define the structure of data sent to and from our Serverless API.

#### VolunteerApplicationPayload

**Description**: The JSON payload sent from the frontend when a user submits the volunteer application form.

**Schema / Interface Definition**:

```typescript
export interface VolunteerApplicationPayload {
  firstName: string;
  lastName: string;
  email: string;
  phone?: string; // Optional phone number
  message: string;
  consent: boolean; // Must be true to submit
}
```
#### NewsletterSubscriptionPayload

**Description**: The JSON payload sent from the frontend to the newsletter subscription function.

**Schema / Interface Definition**:

```typescript
export interface NewsletterSubscriptionPayload {
  email: string;
  listType: 'public' | 'volunteer';
}
```
#### MakeWebhookPayload

**Description**: The JSON payload our submit-volunteer-application function sends to the Make.com webhook to trigger the PDF generation workflow.

**Schema / Interface Definition**:

```typescript
export interface MakeWebhookPayload {
  applicant_email: string;
  applicant_firstname: string;
  applicant_lastname: string;
  application_date: string; // ISO 8601 Date string
}
```
### Database Schemas

For the MVP, a traditional managed database (e.g., SQL, NoSQL) is not required.

- **Content Storage**: All website content (Program, BlogPost, Partner, etc.) is stored and managed exclusively within the Storyblok CMS.

- **Dynamic Data Handling**: Data from user submissions (e.g., Volunteer Applications) will be processed in-memory by our Netlify Functions and passed directly to the relevant third-party services (EmailOctopus, Make). For administrative record-keeping, these submissions will be logged securely to a designated cloud spreadsheet (e.g., Google Sheets or Airtable) via an API call from the Netlify function.

This approach minimizes infrastructure management overhead and cost, aligning perfectly with the serverless and headless architecture for this MVP.

## Core Workflow / Sequence Diagrams

Here are the sequence diagrams for the key workflows in the system.

### Workflow 1: Volunteer Application Submission

This diagram illustrates the end-to-end process when a user submits a volunteer application, involving the frontend, our serverless API, and external automation services.



```
sequenceDiagram
    participant User
    participant Frontend (React Form)
    participant Serverless API (Volunteer Fn)
    participant EmailOctopus API
    participant Make.com Webhook
    User->>+Frontend (React Form): Fills out and submits application
    Frontend (React Form)->>Frontend (React Form): Performs client-side validation
    Frontend (React Form)->>User: Shows "Submitting..." UI state
    Frontend (React Form)->>+Serverless API (Volunteer Fn): POST /submit-volunteer-application with VolunteerApplicationPayload
    Serverless API (Volunteer Fn)->>Serverless API (Volunteer Fn): Validates incoming data
    Serverless API (Volunteer Fn)->>+EmailOctopus API: POST contact data for confirmation email
    EmailOctopus API-->>-Serverless API (Volunteer Fn): Returns success/error
    Serverless API (Volunteer Fn)->>+Make.com Webhook: POST MakeWebhookPayload to trigger PDF generation
    Make.com Webhook-->>-Serverless API (Volunteer Fn): Returns success/error
    Serverless API (Volunteer Fn)-->>-Frontend (React Form): Returns final success/error response
    Frontend (React Form)->>User: Updates UI to show "Success!" or "Error" message
```
### Workflow 2: Content Update and Deployment

This diagram shows the CI/CD process for content, from a change in the CMS to the deployment of the updated site.



```
sequenceDiagram
    participant Content Editor
    participant Storyblok CMS
    participant Netlify
    participant Website Visitor
    Content Editor->>+Storyblok CMS: Creates, updates, or deletes content
    Storyblok CMS->>Content Editor: Saves content in "Draft" state
    Content Editor->>+Storyblok CMS: Clicks "Publish"
    Storyblok CMS->>+Netlify: Triggers build hook via Webhook
    Netlify->>Netlify: Starts new build process
    Netlify->>+Storyblok CMS: Fetches all published content via API
    Storyblok CMS-->>-Netlify: Returns content data
    Netlify->>Netlify: Generates static site (HTML, CSS, JS)
    Netlify->>Netlify: Deploys new files to global CDN
    Netlify-->>-Storyblok CMS: Build success/failure notification
    Netlify-->>-Content Editor: (Implicit) Site is live with changes
    Website Visitor->>+Netlify: Requests a page
    Netlify-->>-Website Visitor: Serves the newly updated static page
```
### Workflow 3: Interactive Program Filtering (Client-Side)

This diagram details how a user filters programs on the website. This entire workflow occurs on the client-side within the browser after the initial page load.


```
```
sequenceDiagram
    participant User
    participant Browser
    participant React (ProgramFilter Component)
    User->>+Browser: Navigates to the /programs page
    Browser->>Browser: Renders the page with the ProgramFilter component, initialized with a full list of all programs.
    User->>+React (ProgramFilter Component): Clicks on a filter option (e.g., a checkbox for "Robotics")
    React (ProgramFilter Component)->>React (ProgramFilter Component): Event handler updates internal state (useState) with the new filter.
    React (ProgramFilter Component)->>React (ProgramFilter Component): Triggers a re-render. The component's logic filters the original full list of programs based on the new state.
    React (ProgramFilter Component)->>-Browser: Renders the updated view showing only the filtered programs.
    Note right of Browser: No new API calls are made.<br/>The entire operation is client-side.
```
```
## Definitive Tech Stack Selections

This table constitutes our definitive technology stack. All development will adhere strictly to this list.

| Category | Technology | Version / Details | Description / Purpose | Justification (Optional) |
|----------|------------|-------------------|----------------------|--------------------------|
| Languages | TypeScript | 5.8.3 | Primary language for type safety in the frontend and backend functions. | Ensures code quality and maintainability. |
| Runtime | Node.js | >=18 (LTS) | Execution environment for Astro, Vite, and Netlify Functions. | Implied by the pnpm v10.11.0 and Astro v5.9 requirements. |
| Frameworks | Astro | 5.9 | Core frontend framework for building a fast, content-focused static site. | Excellent performance via SSG and Island Architecture. |
| Frameworks | React | 19.0.0 | UI library for creating interactive "islands" within the Astro site. | Used for forms, filters, and other dynamic components. |
| CMS | Storyblok | 7.0.0 | Headless CMS for all website content, enabling non-technical content management. | Supports bilingual content and has a robust API. |
| Styling | Tailwind CSS | 4.1.7 | A utility-first CSS framework for rapid and consistent UI styling. | Used with @tailwind/vite integration. |
| Infrastructure | Netlify | @astrojs/netlify@4.3.0 | Platform for hosting, serverless functions, and deployment. | Provides a unified solution for the project's needs. |
| Infrastructure | Turborepo | - | High-performance build system for managing the monorepo. | Optimizes build and test times across the project. |
| Package Manager | pnpm | 10.11.0 | Fast, disk space-efficient package manager for the monorepo. | - |
| CI / CD | GitHub Actions | - | Automation platform for continuous integration and deployment workflows. | - |
| Build Tools | Vite | 6.0 | The underlying build tool used by Astro for fast development and bundling. | - |
| Testing | Vitest | - | Testing framework for unit and integration tests. | - |
| Testing | Testing Library | - | Family of packages for testing UI components in a user-centric way. | - |
| Testing | Playwright | - | Framework for reliable end-to-end testing across browsers. | - |
| Testing | Lighthouse CI | - | Automated auditing for performance, accessibility, and SEO. | - |
| Analytics | Google Analytics 4 | - | Service for tracking user behavior and site traffic. | - |
| Analytics | Netlify Analytics | - | Server-side analytics for additional insights. | - |
| External Services | EmailOctopus | - | Service for managing newsletter lists and sending transactional emails. | Used by the serverless functions. |
| External Services | Make.com | SaaS Platform | Workflow automation platform used to generate and email the Vulnerable Sector Check letter. | Offloads complex document generation from the serverless function. |

## Infrastructure and Deployment Overview

**Cloud Provider(s)**: The entire platform will be hosted and deployed on Netlify.

**Core Services Used**: We will leverage Netlify's integrated services for a unified workflow:

- **Static Hosting**: For serving the statically-generated Astro site from Netlify's global CDN.

- **Serverless Functions**: For executing all backend logic, such as form submissions and API integrations.

- **Netlify Analytics**: For privacy-focused, server-side analytics tracking.

**Infrastructure as Code (IaC)**: The primary configuration for our infrastructure, including build settings, redirects, and function routing, will be managed declaratively in a netlify.toml file committed to the root of the repository.

**Deployment Strategy**: A continuous integration and deployment (CI/CD) model will be used, managed through GitHub Actions and Netlify's build system. The strategy follows a trunk-based or GitHub Flow model where the main branch represents the production state.

**Environments**: We will utilize three distinct environments:

- **Development**: A developer's local machine, running the site via the pnpm dev command.

- **Staging / Preview**: Netlify automatically generates a unique, shareable "Deploy Preview" for every pull request submitted. This serves as our staging environment for reviewing and testing changes before they are merged into production.

- **Production**: The live website, which is deployed automatically when changes are merged into the main branch.

**Environment Promotion**: The process for promoting code to production is simple and review-focused:

1. A developer pushes changes to a feature branch and opens a pull request against the main branch.

2. Netlify automatically builds the site and provides a unique Deploy Preview URL for that pull request.

3. Stakeholders review and approve the changes on the isolated Deploy Preview.

4. Once approved, the pull request is merged into the main branch.

5. This merge triggers an automatic build and deployment to the production environment.

**Rollback Strategy**: Netlify provides a built-in, atomic rollback capability. If a production deployment introduces an issue, we can instantly roll back to any previous successful deployment with a single click in the Netlify dashboard.

## Error Handling Strategy
### General Approach
Our strategy is to handle errors gracefully at the layer they occur, providing helpful feedback to users while logging detailed technical information for developers.

Frontend (Astro + React): The primary goal on the frontend is to prevent UI crashes. Errors, whether from user input, component rendering, or API calls, will be caught and translated into clear, non-technical messages for the user. We will use React's "Error Boundary" components to wrap major UI sections.

Serverless Functions (Netlify): Each function will be self-contained and resilient. All core logic will be wrapped in try...catch blocks. Functions must always return a predictable JSON response with an appropriate HTTP status code (e.g., 200 OK, 400 Bad Request, 500 Internal Server Error) to the client.

### Logging
Frontend Logging: During development, errors will be logged to the browser console via console.error(). For production, we will implement a basic error boundary that logs the error details, allowing us to capture issues faced by real users.

Serverless Function Logging: We will use the native console object available in the Node.js runtime on Netlify. Netlify automatically captures and displays all console output in the function logs for each invocation.

Format: To ensure logs are easily searchable, we will log errors as structured JSON strings: console.error(JSON.stringify({ timestamp: new Date().toISOString(), message: 'Error message', details: ... })).

PII Sanitization: No Personally Identifiable Information (PII) will be logged in plain text. Sensitive data will be sanitized or omitted from error logs.

### Specific Handling Patterns

**External API Calls (within Netlify Functions)**:

- All calls to external services (EmailOctopus, Make.com) must be wrapped in try...catch blocks.

- If an external API returns a non-successful status code (e.g., 4xx or 5xx), our function will log the specific error returned by the API but will return a generic 500 Internal Server Error response to our own frontend to avoid leaking implementation details.

- A simple retry mechanism (e.g., one retry after a 1-second delay) will be implemented for transient network failures or 502/503 errors from external services.

**Frontend Form Submissions**:

- Our React form components will use a try...catch block when calling our Netlify Functions.

- The component will maintain a state (e.g., 'idle' | 'submitting' | 'success' | 'error').

- On a successful submission, the UI will display a clear success message.

- If the call fails (due to a network issue or an error response from the function), the UI will display a user-friendly error message (e.g., "Sorry, we couldn't submit your application. Please try again.") and the submit button will be re-enabled.

## Coding Standards

This project will follow a Test-Driven Development (TDD) methodology where practical, particularly for business logic and utility functions. Unit tests should be written before the implementation code they are intended to validate.

**Style Guide & Linter**: The project will use ESLint and Prettier for static analysis and code formatting. A strict, shared configuration will be enforced via a lint script in package.json.

**Rule**: All linting and type-checking issues reported in the VS Code Problems tab must be resolved before committing code. The only exceptions are for warnings related to environment variables or secrets that cannot be resolved locally.

**Naming Conventions**:

- **Variables & Functions**: camelCase

- **Classes, Types, & Interfaces**: PascalCase

- **React Components**: PascalCase (e.g., ProgramFilter.tsx)

- **Constants**: UPPER_SNAKE_CASE

- **Files**: kebab-case.ts for most files, but PascalCase.tsx for React components.

**File Structure**: All code must adhere strictly to the layout defined in the "Project Structure" section of this document.

**Unit Test File Organization**: Unit test files must be co-located with their source files using the *.test.ts or *.spec.ts naming convention (e.g., utils.ts and utils.spec.ts in the same folder).

**Asynchronous Operations**: All asynchronous operations must use the async/await syntax. Direct use of .then() and .catch() on Promises is discouraged unless required for a specific pattern not achievable with await.

**Type Safety**:

- TypeScript's strict mode must be enabled in the root tsconfig.json.

- The use of the any type is strictly forbidden except in rare, well-justified cases that must be documented with a comment explaining the reason.

- Shared, reusable types and interfaces must be defined in the packages/types/ directory.

**Comments & Documentation**:

- Complex or non-obvious business logic must be accompanied by comments explaining the "why," not the "what."

- All exported functions, types, and classes should have TSDoc-formatted comments explaining their purpose, parameters, and return values.

**Dependency Management**: All dependencies will be managed by pnpm. Versions should be pinned in package.json to ensure deterministic builds. Adding a new dependency requires a brief justification of its necessity.

### Detailed Language & Framework Conventions (TypeScript/Node.js)

**Immutability**: Prefer immutable data structures. Avoid direct mutation of state, objects, or arrays. Use methods like map, filter, and reduce, or the spread syntax (...) to create new copies.

**Error Handling**: Always throw instances of Error or a custom class that extends Error. Custom error classes should be used for domain-specific exceptions.

**Null/Undefined Handling**: strictNullChecks must be enabled. Avoid the non-null assertion operator (!). Use explicit checks, optional chaining (?.), and the nullish coalescing operator (??) to safely handle potentially null or undefined values.

**Module System**: Use ESModules (import/export) exclusively.

**React Idioms**: All React components must be functional components using Hooks. Class components are not permitted. State should be managed according to the principles outlined in the Frontend Architecture document.

## Overall Testing Strategy

This strategy outlines the project's comprehensive approach to quality assurance, which all AI-generated and human-written code must adhere to.

**Tools**: Our testing efforts will be supported by Vitest for unit and integration testing, Testing Library for user-centric component testing, and Playwright for end-to-end browser testing.

**Unit Tests**:

- **Scope**: To test individual functions, methods, and React components in complete isolation. The focus is on verifying business logic, transformations, and component rendering based on props.

- **Location**: Test files will be co-located with their source files, using the *.test.ts or *.spec.ts naming convention.

- **Mocking/Stubbing**: We will use Vitest's built-in mocking capabilities (vi.mock) to isolate the unit under test from its dependencies, such as external API clients or other modules.

- **AI Agent Responsibility**: Following our TDD approach, the AI agent must generate comprehensive unit tests covering all significant logic paths, edge cases, and error conditions before writing the implementation code for any new or modified function/component.

**Integration Tests**:

- **Scope**: To test the interaction between several internal components. This includes testing complete user-facing features (like the volunteer form interacting with its child inputs and form state logic) and testing our serverless functions' integration with mocked external APIs.

- **Location**: These tests will reside in *.test.ts/*.spec.ts files alongside the primary feature or function being tested.

- **AI Agent Responsibility**: The agent is responsible for creating integration tests for key features, such as verifying that the entire volunteer application form can be filled out and that a valid data payload is prepared for submission.

**End-to-End (E2E) Tests**:

- **Scope**: To validate complete user journeys in a real browser environment, ensuring all parts of the system (frontend UI, serverless functions, and live external service integrations where feasible) work together correctly.

- **Tools**: Playwright.

- **Critical Test Journeys**: The following flows must be covered by E2E tests:

  - **Volunteer Application**: A user successfully navigates to, fills out, and submits the volunteer form, and is presented with a success message.

  - **Program Filtering**: A user navigates to the program hub, applies a filter, and verifies that the displayed list of programs updates correctly.

  - **Bilingual Navigation**: A user lands on an English page, uses the language toggle, and verifies they are correctly navigated to the corresponding French version of that page.

**Test Coverage**:

- **Target**: We will aim for a minimum of 80% line coverage for unit tests as a quality baseline. However, the quality and relevance of tests are more important than the raw percentage.

- **Measurement**: Coverage will be measured using Vitest's built-in coverage reporting capabilities.

**Test Data Management**:

- For unit and integration tests, mock data (e.g., mock Program or BlogPost objects) will be defined as constants within the test files.

- For E2E tests, tests will run against a dedicated "development" or "staging" space in Storyblok to ensure a stable and predictable set of content.

## Security Best Practices

**Input Sanitization and Validation**:

- All data received from external sources, primarily from frontend forms submitted to our Netlify Functions, must be rigorously validated on the server-side before processing.

- We will use a schema validation library (e.g., Zod) within each Netlify Function to ensure incoming payloads match our expected data models. Requests that fail validation will be rejected with a 400 Bad Request status.

**Output Encoding**:

- The project will rely on the default output encoding provided by Astro and React's JSX rendering, which protects against Cross-Site Scripting (XSS) attacks.

- The use of mechanisms that bypass this protection (e.g., dangerouslySetInnerHTML) is forbidden unless the content is first passed through an HTML sanitization library like DOMPurify.

**Secrets Management**:

- All API keys (for Storyblok, EmailOctopus), secret webhook URLs (for Make.com), and other credentials must be stored as secure environment variables in the Netlify platform.

- No secrets are to be hardcoded in the source code or committed to the Git repository. The .gitignore file must prevent .env files from being tracked.

**Dependency Security**:

- A dependency audit using pnpm audit will be integrated into our GitHub Actions CI/CD pipeline.

- The build will be configured to fail if any new dependencies introduce high or critical severity vulnerabilities. Existing vulnerabilities must be reviewed and triaged regularly.

**API Security & Access Control**:

- All Netlify Functions acting as API endpoints must be configured to only accept the HTTP methods they are designed for (e.g., POST).

- CORS (Cross-Origin Resource Sharing) policies will be configured on our functions to only allow requests originating from our production domain.

- Rate limiting will be enabled on our serverless functions via Netlify's configuration to protect against denial-of-service and brute-force attacks.

**Data Privacy (PIPEDA Compliance)**:

- As required by PIPEDA, the Volunteer Application form must feature a mandatory consent checkbox. The label for this checkbox must clearly state what data is being collected and for what purpose.

- The data payload sent to third-party services (like Make.com) will be minimized to include only the fields necessary for that specific service to perform its function.

- All communication must occur over HTTPS to ensure data is encrypted in transit.

## Conclusion
This document represents the complete technical architecture for the Colourfully Digital Foundation's MVP website. We have defined a modern, scalable, and secure system based on headless and serverless principles. The architecture directly supports all specified MVP features, from bilingual content management to complex workflow automations for volunteer applications.

All technology choices, development patterns, workflows, testing strategies, and security requirements have been formally documented. This blueprint provides a clear and unambiguous guide for the development phase, ensuring consistency and quality. The document has been validated against the core tenets of the Architect Solution Validation Checklist, satisfying the requirements for clarity, completeness, and technical soundness.